---
lang: zh-CN
title: 基础代码
titleTemplate: 数据结构基础代码（注释版）
description: 学好数据结构，走遍天下都不怕
aside: left
lastUpdated: true
sidebar: false
footer: false
prev:
  text: 'C语言|基础'
  link: '/study/408/C语言/c'
next:
  text: '第二篇|线性表'
  link: '/study/408/Data_Structure/线性表'  
---

```markdown
# 数据结构绪论

## 1. 什么是数据结构？

**数据结构 (Data Structure)** 是计算机存储、组织数据的方式。它是指相互之间存在一种或多种特定关系的数据元素的集合，并定义了对这些数据元素进行操作的方法。

简单来说，数据结构就是 **数据的组织结构 + 操作这种结构的算法**。

*   **数据 (Data)**：所有能输入到计算机中并被处理的符号的总称。
*   **结构 (Structure)**：数据元素之间存在的一种或多种特定关系。

一个好的数据结构可以带来更高的运行或存储效率。

## 2. 为什么需要数据结构？

想象一下图书馆的书籍管理：
*   **无序堆放**：找一本书需要遍历所有书，效率极低 `O(n)`。
*   **按索引号（如杜威十进制法）有序排列**：可以快速定位到书架，效率很高 `O(log n)`。

这里的“索引号”就是一种组织书籍的“数据结构”。同样，在程序中，选择合适的数据结构至关重要，因为它直接决定了：

1.  **程序的运行效率**：算法的执行时间和资源消耗。
2.  **程序的可维护性**：清晰的数据组织方式使代码更易读、易修改、易扩展。
3.  **问题的建模能力**：许多现实世界的问题（如地图导航、社交网络）本身就具有复杂的结构，需要相应的数据结构来模拟。

**著名公式：程序 = 数据结构 + 算法 (Program = Data Structure + Algorithm)**
这充分说明了数据结构和算法是构建高效程序的基石，二者密不可分。

## 3. 基本概念和术语

- **数据 (Data)**：信息的载体。
- **数据元素 (Data Element)**：数据的基本单位，也称为**记录**或**节点**。例如：一个学生信息。
- **数据项 (Data Item)**：构成数据元素的不可分割的最小单位。例如：学生的学号、姓名。
- **数据对象 (Data Object)**：性质相同的数据元素的集合，是数据的子集。例如：所有学生信息的集合。
- **数据结构 (Data Structure)**：数据元素之间的关系集合。包括**逻辑结构**和**物理结构**。

## 4. 数据的逻辑结构 (Logical Structure)

指数据元素之间的逻辑关系，与数据的存储无关。主要分为两大类：

### 4.1 线性结构
数据元素之间存在“一对一”的线性关系。
- **典型结构**：线性表（数组、链表）、栈、队列、字符串。

### 4.2 非线性结构
数据元素之间存在“一对多”或“多对多”的复杂关系。
- **集合**：数据元素同属一个集合，别无其他关系。
- **树形结构**：存在“一对多”的层次关系。例如：家族树、文件目录。
- **图状结构（网状结构）**：存在“多对多”的任意关系。例如：交通网络、社交关系。

## 5. 数据的物理结构（存储结构）(Physical Structure / Storage Structure)

指数据的逻辑结构在计算机中的实际存储方式（映像）。

- **顺序存储结构**：
    - **特点**：用一组连续的存储单元依次存储数据元素。数据间的逻辑关系由存储位置的相邻关系来体现。
    - **优点**：可实现随机存取，存储密度高。
    - **缺点**：插入、删除操作需要移动大量元素；需要预分配连续空间。
    - **典型代表**：数组 (`Array`)。

- **链式存储结构**：
    - **特点**：不要求连续的存储空间。每个数据元素除了存储自身信息外，还存储一个指向下一个元素地址的**指针**。
    - **优点**：插入、删除操作灵活高效；可动态分配空间。
    - **缺点**：存储密度较低（需要额外空间存指针）；不可随机存取。
    - **典型代表**：链表 (`Linked List`)。

- **索引存储结构**：
    - **特点**：在存储数据的同时，还建立了一个附加的索引表。索引表中的每一项（索引项）由关键字和地址组成。
    - **优点**：检索速度快。
    - **缺点**：增删数据时需修改索引表，会额外占用存储空间。
    - **典型代表**：数据库索引。

- **散列存储结构（哈希存储）**：
    - **特点**：根据数据元素的关键字，通过一个**哈希函数**直接计算出一个存储地址。
    - **优点**：检索、增加、删除速度都极快（理想情况下为 `O(1)`）。
    - **缺点**：可能出现**哈希冲突**；存取过程依赖于哈希函数性能。
    - **典型代表**：哈希表 (`Hash Table`)。

> **逻辑结构与物理结构的关系**：
> 一种逻辑结构可以采用不同的物理结构来实现。例如，“线性表”这种逻辑结构，既可以用**顺序存储**（数组）实现，也可以用**链式存储**（链表）实现。选择哪种存储结构取决于需要对线性表进行何种操作。

## 6. 抽象数据类型 (ADT)

**抽象数据类型 (Abstract Data Type, ADT)** 是指一个数学模型以及定义在该模型上的一组操作。

- **“抽象”** 意味着它只关心“做什么”，而不关心“如何做”（即不关心具体实现）。
- 它通过**接口**（操作名称、参数、返回值）来描述行为，而将其具体实现细节隐藏起来。

**ADT 的定义格式通常包括三部分：**
1.  **数据对象**：数据元素集合的定义。
2.  **数据关系**：数据元素之间逻辑关系的定义。
3.  **基本操作**：对数据元素的基本操作方法。

**示例：线性表的 ADT 定义 (伪代码)**
```
ADT List {
    数据对象： D = { a_i | a_i ∈ ElemSet, i=1,2,...,n, n≥0 }
    数据关系： R = { <a_{i-1}, a_i> | a_{i-1}, a_i ∈ D, i=2,...,n }
    基本操作：
        InitList(&L):      初始化一个空线性表L。
        DestroyList(&L):   销毁线性表L。
        ListInsert(&L, i, e): 在位置i插入元素e。
        ListDelete(&L, i, &e): 删除位置i的元素，并用e返回其值。
        GetElem(L, i, &e): 获取位置i的元素值。
        ... // 其他操作
} ADT List
```

## 7. 算法与算法分析

### 7.1 算法的特性
一个算法必须具备以下五个重要特性：
1.  **有穷性**：步骤有限，执行时间有限。
2.  **确定性**：每条指令无二义性，相同输入必得相同输出。
3.  **可行性**：每一步都可通过基本操作实现。
4.  **输入**：有零个或多个输入。
5.  **输出**：有一个或多个输出。

### 7.2 算法效率的度量
通常用**时间复杂度**和**空间复杂度**来衡量算法的优劣。

- **时间复杂度 (Time Complexity)**：算法执行时间随问题规模 `n` 的增长趋势，记作 `T(n) = O(f(n))`。
    - 常见阶：`O(1)` < `O(log n)` < `O(n)` < `O(n log n)` < `O(n²)` < `O(2ⁿ)`
- **空间复杂度 (Space Complexity)**：算法执行所需存储空间随问题规模 `n` 的增长趋势，记作 `S(n) = O(g(n))`。

> 分析复杂度时，关注**最坏情况**下的复杂度通常更有意义。

## 8. 总结：如何学习数据结构？

1.  **理解概念**：理解每种数据结构的逻辑特性和物理实现。
2.  **掌握操作**：熟练掌握对每种数据结构的基本操作（增、删、改、查）及其代码实现。
3.  **分析性能**：学会分析不同操作的时间、空间复杂度，并能根据具体场景选择最合适的结构。
4.  **联系实际**：思考每种数据结构在现实世界和现有软件/系统中的应用（如栈用于函数调用，队列用于消息排队）。
5.  **多写代码**：亲自动手实现课本上的例子和习题，这是理解和巩固知识最有效的方式。

---

**数据结构关系简图：**

```mermaid
graph TD
    A[现实世界问题] --> B[抽象]
    B --> C[逻辑结构<br>(线性/树/图/集合)]
    C --> D[选择物理结构实现]
    D --> E1[顺序存储]
    D --> E2[链式存储]
    D --> E3[索引存储]
    D --> E4[散列存储]
    E1 --> F[具体数据结构<br>（数组、链表、栈、队列、树、图、哈希表...）]
    E2 --> F
    E3 --> F
    E4 --> F
    F --> G[设计高效算法]
    G --> H[解决问题]
```
```